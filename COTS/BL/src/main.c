/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "BL.h"
#include "stm32f446xx.h"
#include "USART_interface.h"
#include "FLASH_interface.h"
#include "RCC_interface.h"
#include "GPIO_interface.h"


#define FLASH_SECTOR_2_BASE_ADDRESS   0x08008000Ul

void BootLoader_UartReadData(void);
void BootLoader_JumpToUserApp(void);

char HelloBootLoader[] = "Hello from Boot Loader\r\n";


USART_Config_t Main_BL_USART2_Config={
		.USART_Baud = USART_BAUD_115200,
		.USART_HWFlowControl = USART_HW_FLOW_CTRL_NONE,
		.USART_Mode = USART_MODE_TXRX,
		.USART_NoOfStopBits = USART_STOPBITS_1,
		.USART_Oversampling = USART_OVERSAMPLING_16,
		.USART_ParityControl = USART_PARITY_DISABLE,
		.USART_SynchMode = ASYNCH,
		.USART_WordLength = USART_WORD_WIDTH_8BITS
};

USART_Handle_t Main_USART2_Handle;
int main(void)
{

	Main_USART2_Handle.USARTx = USART_2;
	Main_USART2_Handle.USART_Config = Main_BL_USART2_Config;
	//Main_USART2_Handle.pTxBuffer = HelloBootLoader;
	RCC_AHB1EnableClk(AHB1_GPIOC);
	RCC_AHB1EnableClk(AHB1_GPIOA);
	RCC_APB1Enable(APB1_USART2);
	RCC_AHB1EnableClk(AHB1_CRC);
  	GPIO_PinConfig_t SwitchPin={
  			.Mode = INPUT,
  			.PinNum = PIN13,
  			.Port = PORTC,
  			.PullType = NOPULL
  	};
  	RCC_AHB1EnableClk(AHB1_GPIOA);
  	GPIO_PinConfig_t Tx_Pin={
  			.Mode = ALTERNATE_FUNCTION,
			.AlFunc = AF7,
			.Port = PORTA,
			.PinNum = PIN2,
			.PullType = NOPULL,

  	};
  	GPIO_PinConfig_t Rx_Pin={
  			.Mode = ALTERNATE_FUNCTION,
			.AlFunc = AF7,
			.Port = PORTA,
			.PinNum = PIN3,
			.PullType = NOPULL,

  	};
  	GPIO_PinConfig_t Clk_Pin={
  			.Mode = ALTERNATE_FUNCTION,
			.AlFunc = AF7,
			.Port = PORTA,
			.PinNum = PIN4,
			.PullType = NOPULL
  	};
	GPIO_PinConfig_t LEDPin={
			.Mode = OUTPUT,
			.PinNum = PIN5,
			.Port = PORTA,
			.OutputType = PUSH_PULL,
			.PullType = NOPULL
	};
  	GPIO_u8PinInit(&Clk_Pin);
  	uint8_t PinVal;
  	GPIO_u8ReadPinValue(PORTC, PIN13, &PinVal);
  	GPIO_u8PinInit(&LEDPin);
  	GPIO_u8PinInit(&SwitchPin);
  	GPIO_u8PinInit(&Tx_Pin);
  	GPIO_u8PinInit(&Rx_Pin);
  	uint8_t Local_u8Error = USART_u8Init(&Main_USART2_Handle);
	  if( PinVal == PIN_LOW)
	  {
		  USART_u8SendData(&Main_USART2_Handle, (uint8_t*)HelloBootLoader, sizeof(HelloBootLoader));
		  BootLoader_UartReadData();
	  }
	  else
	  {
		  USART_u8SendData(&Main_USART2_Handle, (uint8_t*)HelloBootLoader, sizeof(HelloBootLoader));
		  BootLoader_JumpToUserApp();
	  }
    /* Loop forever */
	for(;;)
	{

		  USART_u8SendData(&Main_USART2_Handle, (uint8_t*)HelloBootLoader, sizeof(HelloBootLoader));

	}
}
void BootLoader_UartReadData(void)
{
	/*This function is used to read commands from host*/
	uint8_t Local_u8CmdPacket[255] = {0};

	Main_USART2_Handle.pRxBuffer = Local_u8CmdPacket;

	while(1)
	{
		/*Clear the command packet every iteration*/
		memset(Local_u8CmdPacket,0,255); /*This function is used to set memory*/

		/*1st step : read the first byte which include "length to follow" field of the command */

		USART_u8ReceiveData(&Main_USART2_Handle, Local_u8CmdPacket, 1);
		/*2nd step : read the rest of the command, its size is the previously byte value*/

		USART_u8ReceiveData(&Main_USART2_Handle,&Local_u8CmdPacket[1], Local_u8CmdPacket[0]);

		/*3rd step check the command code then handle the code*/
		switch(Local_u8CmdPacket[1])    /*this byte includes the command code*/
		{
        case BL_GET_VER    		   : BL_voidHandleGetVerCmd(Local_u8CmdPacket);  break;
		case BL_GET_HELP   		   : BL_voidHandleGetHelpCmd(Local_u8CmdPacket);  break;
		case BL_GET_CID    		   : BL_voidHandleGetCIDCmd(Local_u8CmdPacket);  break;
		case BL_GET_RDP_STATUS     : BL_voidHandleGetRDPStatusCmd(Local_u8CmdPacket); break;
		case BL_GO_TO_ADDR    	   : BL_voidHandleGoToAddressCmd(Local_u8CmdPacket);  break;
		case BL_FLASH_ERASE    	   : BL_voidHandleFlashEraseVerCmd(Local_u8CmdPacket);  break;
		case BL_MEM_WRITE    	   : BL_voidHandleMemWriteCmd(Local_u8CmdPacket);  break;
		case BL_EN_RW_PROTECT      : BL_voidHandleEnRWProtectCmd(Local_u8CmdPacket);  break;
		case BL_MEM_READ    	   : BL_voidHandleMemReadCmd(Local_u8CmdPacket);  break;
		case BL_READ_SECTOR_STAUS  : BL_voidHandleReadSectorCmd(Local_u8CmdPacket);  break;
		case BL_OTP_READ    	   : BL_voidHandleOTPReadCmd(Local_u8CmdPacket);  break;
		case BL_DIS_RW_PROTECT     : BL_voidHandleDisableRWProtectCmd(Local_u8CmdPacket);  break;

		}

	}
}
void BootLoader_JumpToUserApp(void)
{
	/*Pointer to function to hold the Reset handler of the user app*/
	void (*App_ResetHandler)(void);

	uint32_t ResetHandler_Adress;

	/*configure MSP of user app by reading value from sectro 2 base address*/
	uint32_t Loacal_u32MSPVal = *((volatile uint32_t*)(FLASH_SECTOR_2_BASE_ADDRESS));

	/*Write the user msp value into MSP register*/
	__asm volatile ("MSR MSP, %0"::"r"(Loacal_u32MSPVal));

	/*Get reset handler address of user App*/
    ResetHandler_Adress = *((volatile uint32_t*)(FLASH_SECTOR_2_BASE_ADDRESS + 4));

    App_ResetHandler = (void*)ResetHandler_Adress;

    /*Jump to the user app reset handler*/
    App_ResetHandler();
}
